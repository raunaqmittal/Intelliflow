/*
 API Smoke Test Script
 Sequentially exercises core endpoints across lifecycle:
 1. Employee signup (manager) + login
 2. Client signup + login
 3. Create client request
 4. Generate workflow for request
 5. Manager department approval (after setting approvesDepartments)
 6. Assign employees to tasks
 7. Approve request -> auto project + tasks creation
 8. Project queries (stats, by status, by client, single project, client-status)
 9. Task queries (stats, my-tasks, by project, update task status, advance sprint)
 10. Negative authorization tests (client attempting manager-only route)

 Usage:
   node Back End/tests/apiSmokeTest.js
 Optional env:
   BASE_URL (default http://localhost:3000/api/v1)
   VERBOSE=true for detailed responses

 NOTE: This script mutates the database. Use a test database if possible.
*/

const axios = require('axios');
const crypto = require('crypto');

const BASE_URL = process.env.BASE_URL || 'http://localhost:3000/api/v1';
const VERBOSE = process.env.VERBOSE === 'true';

function log(msg) { console.log(msg); }
function verbose(obj) { if (VERBOSE) console.dir(obj, { depth: 4 }); }
function assert(condition, message) {
  if (!condition) throw new Error('ASSERTION FAILED: ' + message);
}

async function run() {
  const summary = [];
  const record = (step, success, info) => summary.push({ step, success, info });
  const unique = Date.now();
  const managerEmail = `manager_${unique}@example.com`;
  const clientEmail = `client_${unique}@example.com`;
  const password = 'TestPass123!';

  let managerToken, clientToken, requestId, projectId, firstTaskId, managerEmployeeDoc;

  try {
    log('1. Signup manager employee');
    const signupManagerRes = await axios.post(`${BASE_URL}/employees/signup`, {
      employee_id: unique % 1000000,
      name: 'Test Manager',
      email: managerEmail,
      password,
      passwordConfirm: password,
      role: 'manager',
      department: 'Development',
      availability: 'Available',
      skills: ['leadership','planning']
    });
    assert(signupManagerRes.data.status === 'success', 'Manager signup failed');
    managerToken = signupManagerRes.data.token;
    managerEmployeeDoc = signupManagerRes.data.data.user;
    record('manager_signup', true, managerEmployeeDoc._id);

    log('2. Signup client');
    const signupClientRes = await axios.post(`${BASE_URL}/clients/signup`, {
      client_id: unique % 1000000,
      client_name: 'Smoke Client',
      contact_email: clientEmail,
      password,
      passwordConfirm: password,
      phone: '1234567890',
      industry: 'Testing',
      address: '123 Test Street'
    });
    assert(signupClientRes.data.status === 'success', 'Client signup failed');
    clientToken = signupClientRes.data.token;
    record('client_signup', true, signupClientRes.data.data.user._id);

    log('3. Client login (redundant check)');
    const clientLogin = await axios.post(`${BASE_URL}/clients/login`, { email: clientEmail, password });
    assert(clientLogin.data.status === 'success', 'Client login failed');
    clientToken = clientLogin.data.token; // refresh token
    record('client_login', true, null);

    log('4. Create request as client');
    const reqRes = await axios.post(`${BASE_URL}/requests`, {
      requestType: 'web_dev',
      title: 'Smoke Test Project',
      description: 'A project generated by API smoke test',
      requirements: ['auth','dashboard','reporting']
    }, { headers: { Authorization: `Bearer ${clientToken}` }});
    assert(reqRes.data.status === 'success', 'Create request failed');
    requestId = reqRes.data.data.request._id;
    record('create_request', true, requestId);

    log('5. Generate workflow for request (client allowed)');
    const wfRes = await axios.post(`${BASE_URL}/requests/${requestId}/generate-workflow`, {}, { headers: { Authorization: `Bearer ${clientToken}` }});
    assert(wfRes.data.status === 'success', 'Workflow generation failed');
    const taskBreakdown = wfRes.data.data.request.generatedWorkflow.taskBreakdown || [];
    assert(taskBreakdown.length > 0, 'No tasks generated in workflow');
    record('generate_workflow', true, taskBreakdown.length);

    log('6. Patch manager with approvesDepartments so they can approve');
    // Security note: employee patch route is currently unprotected.
    // Use all unique departments from the provided employee dataset for full coverage
    const deptList = [
      'Design',
      'Development',
      'Product Management',
      'Research',
      'Industrial Engineering',
      'DevOps',
      'Testing',
      'Sales'
    ];
    const patchRes = await axios.patch(`${BASE_URL}/employees/${managerEmployeeDoc._id}`, {
      approvesDepartments: deptList
    });
    assert(patchRes.data.status === 'success', 'Manager patch failed');
    record('patch_manager_departments', true, deptList);

    log('7. Manager approves all required departments for request');
    // Fetch request to get required departments
    const reqDetails = await axios.get(`${BASE_URL}/requests/${requestId}`, { headers: { Authorization: `Bearer ${managerToken}` }});
    const approvals = reqDetails.data.data.request.approvalsByDepartment || [];
    for (const entry of approvals) {
      if (!entry.approved) {
        const deptApprove = await axios.post(`${BASE_URL}/requests/${requestId}/department-approve`, {
          department: entry.department
        }, { headers: { Authorization: `Bearer ${managerToken}` }});
        assert(deptApprove.data.status === 'success', `Department approval failed for ${entry.department}`);
      }
    }
    record('department_approve', true, approvals.length);

    log('8. Assign employees to tasks (manager)');
    // For assignment we need employee ObjectIds; workflow suggestedEmployees may have them.
    const managerObjId = managerEmployeeDoc._id; // assign manager for test
    const assignmentsPayload = {
      assignments: {}
    };
    for (const task of taskBreakdown) {
      assignmentsPayload.assignments[task._id] = [managerObjId];
    }

    const assignRes = await axios.patch(`${BASE_URL}/requests/${requestId}/assign-employees`, assignmentsPayload, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(assignRes.data.status === 'success', 'Assign employees failed');
    record('assign_employees', true, Object.keys(assignmentsPayload.assignments).length);

    log('9. Approve request -> project + tasks creation');
    // Check if all tasks have employees assigned, else skip and print for manual test
    const reqDetails2 = await axios.get(`${BASE_URL}/requests/${requestId}`, { headers: { Authorization: `Bearer ${managerToken}` }});
    const taskBreakdown2 = reqDetails2.data.data.request.generatedWorkflow?.taskBreakdown || [];
    const unassigned = taskBreakdown2.filter(t => {
      const assignments = reqDetails2.data.data.request.taskAssignments?.[t._id] || [];
      return !assignments || assignments.length === 0;
    });
    if (unassigned.length > 0) {
      log('SKIPPING approval and all dependent steps for this request due to unassigned tasks. Please test manually:');
      log(`Request ID: ${requestId}`);
      log(`Title: ${reqDetails2.data.data.request.title}`);
      log('Unassigned tasks:');
      unassigned.forEach(t => log(`- ${t.taskName || t._id}`));
      record('approve_request', false, 'Skipped due to unassigned tasks. See console for details.');
      // Skip all dependent steps
      log('Skipping project stats, task stats, project/task queries, and sprint advance for this request.');
      return;
    } else {
      const approveRes = await axios.post(`${BASE_URL}/requests/${requestId}/approve`, {}, { headers: { Authorization: `Bearer ${managerToken}` }});
      assert(approveRes.data.status === 'success', 'Approve request failed');
      const project = approveRes.data.data.project;
      projectId = project._id;
      const tasks = approveRes.data.data.tasks || [];
      assert(tasks.length > 0, 'No tasks created from approval');
      firstTaskId = tasks[0]._id;
      record('approve_request', true, { projectId, tasks: tasks.length });
    }

    log('10. Project stats (protected)');
    const projStats = await axios.get(`${BASE_URL}/projects/stats`, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(projStats.data.status === 'success', 'Project stats failed');
    record('project_stats', true, projStats.data.data.totalProjects);

    log('11. Tasks stats (protected)');
    const taskStats = await axios.get(`${BASE_URL}/tasks/stats`, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(taskStats.data.status === 'success', 'Task stats failed');
    record('task_stats', true, taskStats.data.data.totalTasks);

    log('12. Get project by id');
    const projRes = await axios.get(`${BASE_URL}/projects/${projectId}`, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(projRes.data.status === 'success', 'Get project failed');
    record('get_project', true, projRes.data.data.tasks.length);

    log('13. Client-safe project status (client)');
    const clientProjStatus = await axios.get(`${BASE_URL}/projects/${projectId}/client-status`, { headers: { Authorization: `Bearer ${clientToken}` }});
    assert(clientProjStatus.data.status === 'success', 'Client project status failed');
    record('client_project_status', true, clientProjStatus.data.data.taskSummary.total);

    log('14. Get tasks by project');
    const tasksByProject = await axios.get(`${BASE_URL}/tasks/project/${projectId}`, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(tasksByProject.data.status === 'success', 'Tasks by project failed');
    record('tasks_by_project', true, tasksByProject.data.results);

    log('15. Update task status');
    const taskUpdate = await axios.patch(`${BASE_URL}/tasks/${firstTaskId}/status`, { status: 'In Progress' }, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(taskUpdate.data.status === 'success', 'Task status update failed');
    record('task_status_update', true, taskUpdate.data.data.task.status);

    log('16. Negative test: client tries manager-only approve (should 403)');
    let negative403 = false;
    try {
      await axios.post(`${BASE_URL}/requests/${requestId}/reject`, {}, { headers: { Authorization: `Bearer ${clientToken}` }});
    } catch (e) {
      negative403 = e.response && e.response.status === 403;
    }
    assert(negative403, 'Client should not be able to reject request');
    record('negative_client_reject', true, 403);

    log('17. My tasks (manager as employee)');
    const myTasksRes = await axios.get(`${BASE_URL}/tasks/my-tasks`, { headers: { Authorization: `Bearer ${managerToken}` }});
    assert(myTasksRes.data.status === 'success', 'My tasks failed');
    record('my_tasks', true, myTasksRes.data.results);

    log('18. Advance sprint (may fail if tasks not completed)');
    let advanced = false;
    try {
      const advRes = await axios.patch(`${BASE_URL}/projects/${projectId}/advance-sprint`, {}, { headers: { Authorization: `Bearer ${managerToken}` }});
      advanced = advRes.data.status === 'success';
      record('advance_sprint', advanced, advRes.data.data.message);
    } catch (e) {
      record('advance_sprint', false, e.response ? e.response.data.message : e.message);
    }

    log('All steps executed');
  } catch (err) {
    log('FATAL ERROR:\n' + (err.response ? JSON.stringify(err.response.data, null, 2) : err.stack));
    record('fatal', false, err.message);
  }

  log('\nSMOKE TEST SUMMARY');
  summary.forEach(s => {
    log(`${s.success ? '✔' : '✖'} ${s.step}: ${typeof s.info === 'object' ? JSON.stringify(s.info) : s.info}`);
  });

  const failed = summary.filter(s => !s.success);
  if (failed.length) {
    log(`\nFailures: ${failed.length}`);
    process.exitCode = 1;
  } else {
    log('\nAll smoke tests passed (logical checks only).');
  }
}

run();
